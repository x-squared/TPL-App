from __future__ import annotations

import json
from pathlib import Path

from .spec_parser import SpecCase, parse_all_specs

PROJECT_ROOT = Path(__file__).resolve().parents[2]
SPEC_ROOT = PROJECT_ROOT / "spec"
GENERATED_ROOT = PROJECT_ROOT / "qa" / "tests" / "generated"


def _emit_test_file(cases: list[SpecCase], scope: str, output_file: Path, base_env_var: str, base_default: str) -> None:
    cases_payload = [
        {
            "id": c.id,
            "name": c.name,
            "method": c.method,
            "path": c.path,
            "expect_status": c.expect_status,
            "expect_json_subset": c.expect_json_subset,
            "expect_body_contains": c.expect_body_contains,
            "source_file": c.source_file,
        }
        for c in cases
    ]
    cases_json = repr(cases_payload)

    content = f"""# Auto-generated by qa/spec_tools/generate_tests.py
# Scope: {scope}
import json
import os
import unittest
import urllib.error
import urllib.request


BASE_URL = os.getenv("{base_env_var}", "{base_default}").rstrip("/")
CASES = {cases_json}


def _request_json(method: str, url: str):
    req = urllib.request.Request(url, method=method)
    with urllib.request.urlopen(req, timeout=8) as response:
        body = response.read().decode("utf-8")
        return response.status, body


class GeneratedSpecTests(unittest.TestCase):
    def test_cases(self):
        for case in CASES:
            with self.subTest(case_id=case["id"], source=case["source_file"]):
                url = BASE_URL + case["path"]
                try:
                    status, body = _request_json(case["method"], url)
                except urllib.error.HTTPError as exc:
                    status = exc.code
                    body = exc.read().decode("utf-8", errors="replace")
                self.assertEqual(
                    status,
                    case["expect_status"],
                    f"Unexpected HTTP status for {{case['id']}} at {{url}}. Body: {{body[:500]}}",
                )
                for needle in case["expect_body_contains"]:
                    self.assertIn(
                        needle.lower(),
                        body.lower(),
                        f"Expected '{{needle}}' in response body for {{case['id']}}.",
                    )
                if case["expect_json_subset"] is not None:
                    parsed = json.loads(body)
                    for key, expected in case["expect_json_subset"].items():
                        self.assertIn(key, parsed, f"Missing key '{{key}}' in JSON body.")
                        self.assertEqual(parsed[key], expected, f"Unexpected value for key '{{key}}'.")
"""
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(content, encoding="utf-8")


def generate() -> dict[str, int]:
    all_cases = parse_all_specs(SPEC_ROOT)
    server_cases = [c for c in all_cases if c.scope == "server"]
    client_server_cases = [c for c in all_cases if c.scope == "client_server"]

    _emit_test_file(
        server_cases,
        scope="server",
        output_file=GENERATED_ROOT / "test_server_specs.py",
        base_env_var="TPL_TEST_BACKEND_URL",
        base_default="http://localhost:8000",
    )
    _emit_test_file(
        client_server_cases,
        scope="client_server",
        output_file=GENERATED_ROOT / "test_client_server_specs.py",
        base_env_var="TPL_TEST_FRONTEND_URL",
        base_default="http://localhost:5173",
    )

    return {
        "total": len(all_cases),
        "server": len(server_cases),
        "client_server": len(client_server_cases),
    }


if __name__ == "__main__":
    summary = generate()
    print(
        "Generated spec tests: "
        f"total={summary['total']} server={summary['server']} client_server={summary['client_server']}"
    )
