---
description: Structure complex frontend views with thin containers and composed view-model hooks
alwaysApply: true
---

# Complex View Architecture Pattern

For any new complex view (like patients or colloquiums), follow this structure by default:

- **Thin container view**: The top-level `*View.tsx` should mostly render layout/header and pass grouped models to tabs/sections.
- **Section-first decomposition**: In tabs/detail screens, treat each visual section (`<section ...>`) as a component boundary by default. Keep tab containers as orchestration layers and move section UI into focused child components.
- **Composed view-model hook**: Put behavior in `use*ViewModel.ts` that composes focused hooks (`use*Core`, `use*Section`, etc.).
- **Focused hooks**: One hook per concern (core entity loading, contacts, episodes, diagnoses, medical values, agenda, sync), each with clear inputs/outputs.
- **Grouped props, not flat prop lists**: Pass grouped models (`core`, `contacts`, `episodes`, `medicalValues`, ...) into tab components instead of dozens of flat props.
- **Typed contracts**: Define and export explicit model interfaces used across tabs/sections; avoid `any`.
- **File placement**: Keep new files in feature subdirectories under `frontend/src/views/<feature>/...` (e.g. `hooks/`, `tabs/`, `types/`, `utils/`).
- **CSS architecture**:
  - Keep shared/reusable styling in central files (for example shared layout/table/style files).
  - Keep feature CSS in `frontend/src/views/<feature>/...` and scope it to feature-specific behavior only.
  - Always create universally applicable styles where useful.
  - If an existing style pattern is already accepted across views, prefer promoting it to a shared/global style instead of re-implementing it locally.
  - Reuse existing shared class patterns before introducing new classes.
  - Prefer extending shared classes over duplicating style blocks across views.
  - Avoid inline styles except for truly dynamic values that cannot be expressed cleanly via classes.
  - **Visual consistency checklist (required for new tabs/sections):**
    - Use existing panel and heading classes (`ui-panel-section`, `detail-section-heading`) instead of ad-hoc wrappers.
    - Use existing button variants (`patients-save-btn`, `patients-cancel-btn`, `patients-add-btn`, `ci-add-btn`) instead of unstyled/default buttons.
    - Use standard table wrappers/classes (`ui-table-wrap`, `patients-table-wrap`, `data-table`) so spacing, typography, and hover states match.
    - Keep feature-specific style rules in the feature CSS file (for example `AdminView.css`), and avoid adding feature styles to `App.css` unless shared by multiple views.
    - Match existing form rhythm: label + input stacks, consistent gaps, and no custom one-off control sizing unless necessary.
- **Shared rendering utilities**:
  - Centralize repeated display formatting logic (for example dates/times, empty placeholders, labels) in shared utilities under `frontend/src/views/layout/` (or another shared location) instead of duplicating inline logic in components.
  - For date rendering in view output, use shared formatters (for example `dateFormat.ts`) and keep formatting consistent across list/detail/header sections.
  - Do not use ad-hoc `toLocaleDateString()`/manual slicing in components when a shared formatter exists.
- **Editable panel standard**:
  - For data sections in detail views, default to explicit **Edit / Save / Cancel** behavior.
  - Fields are read-only until Edit is clicked; Cancel restores the original data.
  - Save is section-scoped and disabled when there are no changes.
  - Reuse shared panel controls (for example `EditableSectionHeader`) instead of duplicating heading/action markup.
  - Exceptions (autosave/inline editing) must be explicitly requested.
- **Table add/delete consistency**:
  - In table sections, use consistent add button styling (`ci-add-btn`) and placement (in the section heading, right aligned).
  - For table-managed records, default to inline add/edit rows in the table (instead of detached editors), unless a different UX is explicitly requested.
  - Destructive row deletes must require explicit confirmation before execution.
  - Reuse shared row-action components (for example `InlineDeleteActions`) for edit/delete/confirm UI instead of duplicating per-table markup.
  - Keep confirmation wording and Yes/No controls consistent across tables.
- **Behavior preservation**: Refactors must not change UX logic unless explicitly requested.
- **Validation**: After refactors, run frontend build/typecheck and fix all issues before finishing.

Use this pattern for all upcoming complex views unless the user asks for a different architecture.
