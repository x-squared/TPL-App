# Access Control Manual

This manual documents role-based access control (RBAC) in TPL-App:

- how permissions are modeled
- how access is enforced in backend and frontend
- how access rights are managed in the Admin UI

## 1) Core concepts

Two concepts must be kept separate:

- **GUI view**: an application page/screen (for example Donations, Reports, Admin)
- **view-right**: a permission that allows seeing/using a view and its read APIs

Write operations use separate **edit-rights**.

Example policy currently implemented:

- `view.donations` allows viewing donation/coordinations data
- `edit.donations` allows changing donation/coordinations data

So a user can be read-only for Donations when they have `view.donations` but not `edit.donations`.

## 2) Authorization model

TPL-App uses permission-based RBAC:

- **Users** have one or more **roles**
- **Roles** grant **permissions**
- Permissions are string keys (for example `view.reports`, `edit.donations`)

Main entities:

- `USER` and `USER_ROLE` for user/role assignment
- `CODE` entries of type `ROLE`
- `ACCESS_PERMISSION`
- `ROLE_PERMISSION` mapping

## 3) Seeded roles and permissions

Seed source for permission catalog and role mapping:

- `backend/app/seed/datasets/core/access_rules.py`

Seed source for role codes:

- `backend/app/seed/datasets/core/codes.py`

Important role currently used for donation editing:

- `KOORD_DONATION` (separate from generic coordinator role)

## 4) Enforcement architecture

### Backend (source of truth)

Backend enforces access using auth dependencies:

- `require_permission("<permission.key>")`

This is applied on endpoints in routers.

Current donation/coordinations policy:

- read endpoints require `view.donations`
- mutating endpoints require `edit.donations`

### Frontend (UX gating)

Frontend receives `permissions` from auth payload and uses them to:

- hide/show navigation entries
- prevent opening pages without permission

Frontend gating improves UX but is not the security boundary; backend checks are authoritative.

## 5) How permissions are resolved

Auth flow:

1. User logs in (`/api/auth/login`)
2. Backend resolves user roles
3. Backend resolves role-derived permissions
4. Response contains `user.permissions`

Used endpoints:

- `GET /api/auth/me`
- `POST /api/auth/login`

## 6) Managing access rights in Admin

Admin access rules UI is available in:

- **Admin â†’ Access Rules**

API used by Admin UI:

- `GET /api/admin/access/matrix`
- `PUT /api/admin/access/roles/{role_key}`

Typical workflow:

1. Open Admin view.
2. Select a role.
3. Toggle permissions.
4. Save.

Guardrails:

- Admin endpoints require `view.admin`.
- `ADMIN` role must keep `view.admin`.

## 7) Operational steps after RBAC changes

When changing role/permission seed data, refresh schema+data so mappings are consistent.

From `backend/`:

```{bash}
source .venv/bin/activate
python -m app.db_admin --mode refresh --env DEV
```

Then restart backend and re-login in frontend so the token/user payload is refreshed.

## 8) Testing checklist

Minimum manual checks:

1. Login as user with `view.donations` only:
   - Donations/coordinations pages are visible
   - read APIs work
   - create/update/delete donation operations are blocked (403)
2. Login as user with `view.donations` + `edit.donations`:
   - mutation operations succeed
3. Login as user without `view.admin`:
   - Admin view not visible
   - admin access API returns forbidden
4. Change role mapping in Admin tab:
   - save succeeds
   - re-login reflects changed permissions

## 9) Troubleshooting

- **Nav item missing unexpectedly**: verify user has corresponding `view.*` permission.
- **403 on write despite visible page**: user likely lacks `edit.*` permission.
- **Admin updates not reflected**: re-login to refresh user permissions in client state.
- **Role exists but no permissions**: verify seed/access matrix consistency and rerun DB refresh.
