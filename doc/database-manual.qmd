# Database Manual

Purpose: manage schema and data lifecycle explicitly during development and operations.

The backend now separates:

- schema management (DDL): `python -m app.db_schema`
- data management (DML): `python -m app.db_data`
- convenience orchestration: `python -m app.db_admin`

Run commands from `backend/` with the venv activated.

## Quick Examples

```{bash}
cd /Users/stephan/Workspace/TPL-App/backend
source .venv/bin/activate
```

Recreate everything (drop/create schema + seed):

```{bash}
python -m app.db_admin --mode recreate --env DEV
```

Update schema only (keep data):

```{bash}
python -m app.db_schema --mode migrate --env DEV
```

Default refresh (migrate schema + clean data + seed):

```{bash}
python -m app.db_admin --mode refresh --env DEV
```

Clean data only:

```{bash}
python -m app.db_data --mode clean --env DEV
```

## `app.db_schema` (DDL only)

```{bash}
python -m app.db_schema --mode <recreate|migrate|verify> --env <DEV|TEST|PROD> [--db-url <URL>]
```

- `recreate`: drops all tables and creates schema from current model metadata.
- `migrate`: creates missing schema objects from model metadata.
- `verify`: reports schema drift (missing tables/columns), no writes.

Use `verify` in CI or before release checks.

## `app.db_data` (DML only)

```{bash}
python -m app.db_data --mode <clean|seed|refresh> --env <DEV|TEST|PROD> [--seed-profile <PROFILE>] [--db-url <URL>]
```

- `clean`: wipes row data, keeps schema.
- `seed`: loads seed jobs resolved by env/profile.
- `refresh`: `clean + seed`.

### Seed profile resolution

- no profile: resolved from env (`DEV`, `TEST`, `PROD`)
- explicit profile examples:
  - `CORE`
  - `CORE_SAMPLE`
  - `CORE_TEST`
  - `NONE`

Example:

```{bash}
python -m app.db_data --mode seed --env TEST --seed-profile CORE_TEST
```

## `app.db_admin` (wrapper)

```{bash}
python -m app.db_admin --mode <recreate|migrate|refresh|clean> --env <DEV|TEST|PROD> [--seed-profile <PROFILE>] [--db-url <URL>]
```

Mode behavior:

- `recreate` = `db_schema recreate` + `db_data seed`
- `migrate` = `db_schema migrate`
- `refresh` = `db_schema migrate` + `db_data refresh` (default)
- `clean` = `db_data clean`

For `refresh`, if `migrate` cannot reconcile schema drift, the wrapper automatically falls back to `db_schema recreate` before data refresh.

## Recommended Usage by Scenario

Local development reset (most common):

```{bash}
python -m app.db_admin --mode refresh --env DEV
```

After model changes, keep existing data if possible:

```{bash}
python -m app.db_schema --mode migrate --env DEV
```

Production-like schema check in CI:

```{bash}
python -m app.db_schema --mode verify --env PROD
```

## Notes

- If schema is older than current models, `db_data seed` may fail; run schema step first.
- `--db-url` allows targeting a non-default database.
- For SQLite, "clean" keeps the file and clears all table rows.

## Strong Enum Migration Path (carried out)

To reduce drift for stable technical vocabularies while keeping DB compatibility, use this migration path.

### Phase 1 (completed)

- Introduce backend enums in `backend/app/enums.py` for:
  - `COORDINATION_STATUS`
  - `FAVORITE_TYPE`
  - `TASK_SCOPE`
  - `TASK_STATUS`
  - `PRIORITY`
- Replace magic string keys in services with enum constants.
- Keep existing `CODE` table references and foreign keys unchanged (no API break).
- Align core seed data to enum constants in `backend/app/seed/datasets/core/codes.py`.
- Enforce startup alignment check between enum definitions and existing `CODE` rows.

### Phase 2 (completed, compatibility mode)

- Added enum-key persistence columns for strong enum domains:
  - `COORDINATION.STATUS_KEY`
  - `TASK_GROUP_TEMPLATE.SCOPE_KEY`
  - `TASK_TEMPLATE.PRIORITY_KEY`
  - `TASK.PRIORITY_KEY`
  - `TASK.STATUS_KEY`
- Added startup migration/backfill in `backend/app/main.py` to keep key/id mirrors aligned in both directions.
- Updated service write paths and seed loaders so new/updated rows write enum keys deterministically.
- Kept `*_id -> CODE.ID` fields and API contracts for backward compatibility while transitioning consumers to key-based semantics.
